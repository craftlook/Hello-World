# LSM树介绍



> LSM-Tree 被是一种面向写多读少应用场景的数据结构 ，被 Hbase、RocksDB、Elasticsearch 等强力 NoSQL 数据库采用作为底层文件组织方式。文中将会介绍 LSM-Tree 的设计思路，并分析使用 LSM-Tree 的 LevelDB 是如何实现与进行性能优化的。

## LSM-Tree

> 讲LSM树之前，需要提下**三种基本的存储引擎**，这样才能清楚LSM树的由来：
>
> 1. 哈希存储引擎  是哈希表的持久化实现，支持增、删、改以及随机读取操作，但不支持顺序扫描，对应的存储系统为key-value存储系统。对于key-value的插入以及查询，哈希表的复杂度都是O(1)，明显比树的操作O(n)快,如果不需要有序的遍历数据，哈希表就是your Mr.Right
> 2. B树存储引擎是B树[（关于B树的由来，数据结构以及应用场景可以看之前一篇博文）](http://www.cnblogs.com/yanghuahui/p/3483047.html)的持久化实现，不仅支持单条记录的增、删、读、改操作，还支持顺序扫描（B+树的叶子节点之间的指针），对应的存储系统就是关系数据库（Mysql等）。
> 3. LSM树（Log-Structured Merge Tree）存储引擎和B树存储引擎一样，同样支持增、删、读、改、顺序扫描操作。而且通过批量存储技术规避磁盘随机写入问题。当然凡事有利有弊，LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。

LSM-Tree 全称Log Structured Merge Tree，是一种分层、有序、面向磁盘的数据结构，其核心思想是**充分利用磁盘顺序写性能要远高于随机写性能这一特点，将批量的随机写入转化未一次性的顺序写**。与B-tree相比，能显著地减少硬盘磁盘臂的开销。当然凡事有利有弊，LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。

读取时需要合并磁盘中的历史数据和内存中最近的修改操作,**读取时可能需要先看是否命中内存，否则需要访问较多的磁盘文件（存储在磁盘中的是许多小批量数据，由此降低了部分读性能。但是磁盘中会定期做merge操作，合并成一棵大树，以优化读性能）**。LSM树的优势在于有效地规避了磁盘随机写入问题，但读取时可能需要访问较多的磁盘文件。

![avatar]()

从图中可以值观地看出，磁盘的顺序访问速度至少比随机I/O快三个数量级，甚至顺序访问磁盘比随机访问主内存还要快。这意味着尽可能避免随机I/O操作。

LSM-Tree 围绕这一原理进行设计和优化，通过消去随机的更新操作来达到这个目的，以此让写性能达到最优，同时为那些长期具有高更新频率的文件提供低成本的索引机制，减少查询时的开销。

## Two-Component LSM-Tree

LSM-Tree 可以由两个或多个类树的数据结构组件构成，本小节我们先介绍较为简单的两组件情况。

![avatar]()

两组件LSM-Tree 在内存中有一个C0组件，它可以是`AVL`和`skipList`等结构，所有写入首先写道C0中。磁盘上有一个C1组件，当C0组件的大小达到阈值时，就需要进行rolling merge，将内存中的内容合并到C1中。C0和C1组件的写操作流程如下：

1. 当有写操作时，会先将数据追加写到日志文件中，以备必要时恢复；
2. 然后将数据写入位于内存的 C0 组件，通过某种数据结构保持 Key 有序；
3. 内存中的数据定时或按固定大小刷新到磁盘，更新操作只写到内存，并不更新磁盘上已有文件；
4. 随着写操作越来越多，磁盘上积累的文件也越来越多，这些文件不可写但有序，所以我们定时对文件进行合并（Compaction）操作，消除冗余数据，减少文件数量。

> 类似于普通的日志写入方式，这种数据结构的写入，全部都是以`Append`的模式追加，不存在删除和修改。对于任何应用来说，那些会导致索引值发生变化的数据更新都是繁琐且耗时的，但是这样的更新却可以被 LSM-Tree 轻松地解决，将该更新操作看做是**一个删除操作加上一个插入操作**。

C1组件是为了顺序性访问磁盘进行过优化，可以是B-Tree一类的数据结构（LevelDB中实现的是SSTable）,所有系欸但都是100%填充，为了有效利用磁盘，在根节点之下的所有的单页面节点都会被`打包`放到连续的多页面磁盘块（Multi-Page Block）上。对于 Rolling Merge 和长区间检索的情况将会使用 Multi-Page Block I/O，这样就可以有效减少磁盘旋臂的移动；而在匹配性的查找中会使用 Single-Page I/O，以最小化缓存量。通常根节点只有一个单页面，而其它节点使用 256KB 的 Multi-Page Block。

在一个两组件 LSM-Tree 中，只要 C0 组件足够大，那么就会有一个批量处理效果。**例如：**如果一条数据记录的大小是 16Bytes，在一个 4KB 的节点中将会有 250 条记录；如果 C0 组件的大小是 C1 的 1/25，那么在每个合并操作新产生的具有 250 条记录的 C1 节点中，将会有 10 条是从 C0 合并而来的新记录。也就是说用户新写入的数据暂时存储到内存的 C0 中，然后再批量延迟写入磁盘，**相当于将用户之前的 10 次写入合并为一次写入**。显然地，**由于只需要一次随机写就可以写入多条数据，LSM-Tree 的写效率比 B-Tree 等数据结构更高**，而 Rolling Merge 过程则是其中的关键。

## Rolling Merge

