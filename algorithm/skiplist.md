## 跳表(skiplist)

## 数据结构简介

skiplist 跳表全称跳跃列表，本质上是一种查找结构，允许快速查询。插入和删除一个有序连续元素的数据链表，跳跃列表的平均查找和插入时间复杂度都是O(logn)。**快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集(如下图)**。开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。

![avatar](https://github.com/craftlook/Note/blob/master/image/skiplist1.jpg)

## 演化过程

1. skiplist，首先是一个list，实际上在有序链表的基础上发展出来的，首先看有序链表，如图:

![avatar](https://github.com/craftlook/Note/blob/master/image/skiplist2.png)

上图的有序链表，如果需要查找数据，需要从头开始进行比较直到找到**目标数据节点**或者找到第一个比目标数据大的节点为止**（没找到）**。顺序查找的时间复杂度O(n)。插入也要经历查找过程，从而确定保存位置。

2. 如果我们每相邻的两个节点增加一个指针，让指针指向下下一个接单，如图：

![avatar](https://github.com/craftlook/Note/blob/master/image/skiplist3.png)

新增加的指针形成了新的链表，但只包含7，19，26(如上图)。

3. 现在当想查找数据时，可以先沿着新链表进行查找。当碰到**比目标数据大的节点时，再回到原来的链表进行查找**。如图，我们进行23的插入，图中红线是我们的查找路径：

![avatar](https://github.com/craftlook/Note/blob/master/image/skiplist4.png)

* 首先23与7进行比较，23>7 再与19比较；
* 23与26比较时，23<26 回到下面的链表（原链表），与22比较；
* 23>22 沿着指针向后和26比较。23<26 说明 23原链表不存在，插入再22 和 26之间。

上图在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较的节点数大概只有原来的一半

4. 利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。如下图：

![avatar](https://github.com/craftlook/Note/blob/master/image/skiplist5.png)

在这个新的三层链表结构上，如果我们还是查找23，那么沿着最上层链表首先要比较的是19，发现23比19大，接下来我们就知道只需要到19的后面去继续查找，从而一下子跳过了19前面的所有节点。可以想象，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。

skiplist正是受这种多层链表的想法的启发而设计出来的，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。**问题**：这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。

skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是**为每个节点随机出一个层数(level)**。比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程,如图

![avatar](https://github.com/craftlook/Note/blob/master/image/skiplist6.png)

刚刚创建的这个skiplist总共包含4层链表，现在假设我们在它里面依然查找23，下图给出了**查找路径**，如图：

![avatar](https://github.com/craftlook/Note/blob/master/image/skiplist7.png)

需要注意的是，前面演示的各个节点的插入过程，**实际上在插入之前也要先经历一个类似的查找过程**，在确定插入位置后，再完成插入操作。

## skiplist的算法性能分析

我们来简单分析一下skiplist的时间复杂度和空间复杂度,如果你不是特别偏执于算法的性能分析，那么可以暂时跳过这一小节的内容。

### 空间复杂度

根据前面randomLevel()的伪码，我们很容易看出，产生越高的节点层数，概率越低。定量的分析如下：

- 节点层数至少为1。而大于1的节点层数，满足一个概率分布。
- 节点层数恰好等于1的概率为1-p。
- 节点层数大于等于2的概率为p，而节点层数恰好等于2的概率为p(1-p)。
- 节点层数大于等于3的概率为p2，而节点层数恰好等于3的概率为p2(1-p)。
- 节点层数大于等于4的概率为p3，而节点层数恰好等于4的概率为p3(1-p)。
- ……

因此，一个节点的平均层数（也即包含的平均指针数目），计算如下：

![avatar](https://github.com/craftlook/Note/blob/master/image/skiplist8.png)

现在很容易计算出：

- 当p=1/2时，每个节点所包含的平均指针数目为2；
- 当p=1/4时，每个节点所包含的平均指针数目为1.33。这也是Redis里的skiplist实现在空间上的开销。

### 时间复杂度

查找长度指的是查找路径上跨越的跳数，而查找过程中的比较次数就等于查找长度加1。以前面图中标出的查找23的查找路径为例，从左上角的头结点开始，一直到结点22，查找长度为6。

为了计算查找长度，这里我们需要利用一点小技巧。我们注意到，每个节点插入的时候，它的层数是由随机函数randomLevel()计算出来的，而且随机的计算不依赖于其它节点，每次插入过程都是完全独立的。所以，从统计上来说，一个skiplist结构的形成与节点的插入顺序无关。

这样的话，为了计算查找长度，我们可以将查找过程倒过来看，从右下方第1层上最后到达的那个节点开始，沿着查找路径向左向上回溯，类似于爬楼梯的过程。我们假设当回溯到某个节点的时候，它才被插入，这虽然相当于改变了节点的插入顺序，但从统计上不影响整个skiplist的形成结构。

现在假设我们从一个层数为i的节点x出发，需要向左向上攀爬k层。这时我们有两种可能：

- 如果节点x有第(i+1)层指针，那么我们需要向上走。这种情况概率为p。
- 如果节点x没有第(i+1)层指针，那么我们需要向左走。这种情况概率为(1-p)。

用C(k)表示向上攀爬k个层级所需要走过的平均查找路径长度（概率期望），那么：

```
C(0)=0
C(k)=(1-p)×(上图中情况b的查找长度) + p×(上图中情况c的查找长度)
```

代入，得到一个差分方程并化简：

```
C(k)=(1-p)(C(k)+1) + p(C(k-1)+1)
C(k)=1/p+C(k-1)
C(k)=k/p
```

这个结果的意思是，我们每爬升1个层级，需要在查找路径上走1/p步。而我们总共需要攀爬的层级数等于整个skiplist的总层数-1。

那么接下来我们需要分析一下当skiplist中有n个节点的时候，它的总层数的概率均值是多少。这个问题直观上比较好理解。根据节点的层数随机算法，容易得出：

- 第1层链表固定有n个节点；
- 第2层链表平均有n*p个节点；
- 第3层链表平均有n*p2个节点；
- …

所以，从第1层到最高层，各层链表的平均节点数是一个指数递减的等比数列。容易推算出，总层数的均值为log1/pn，而最高层的平均节点数为1/p。

综上，粗略来计算的话，平均查找长度约等于：

- C(log1/pn-1)=(log1/pn-1)/p

即，平均时间复杂度为**O(log n)**。

当然，这里的时间复杂度分析还是比较粗略的。比如，沿着查找路径向左向上回溯的时候，可能先到达左侧头结点，然后沿头结点一路向上；还可能先到达最高层的节点，然后沿着最高层链表一路向左。但这些细节不影响平均时间复杂度的最后结果。另外，这里给出的时间复杂度只是一个概率平均值，但实际上计算一个精细的概率分布也是有可能的。详情还请参见[William Pugh](https://en.wikipedia.org/wiki/William_Pugh)的论文《[Skip Lists: A Probabilistic Alternative to Balanced Trees](ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf)》
