# 二叉查找树、平衡二叉树、B树、B+树

#### 目录

* [二叉树](#2tree)
* [平衡二叉树](#avg-tree)
* [B tree](#b-tree)
* [B+ tree](#b+-tree)
* [B* tree](#bb-tree)
* [总结](#summary)

## <span id="2Tree">二叉查找树</span>(BST)

特殊的二叉树，其他称谓排序二叉树、二叉搜索树、二叉排序树。

二叉查找树实际上是数据域有序的二叉树，即树上的每个节点，都满足**左子树**上的所有数据域的值**小于或等于根节点**，右子树上的所有数据域的值均**大于根节点**。

### 查找

对于二叉查找树的查找有递归模式和非递归两种。

* 递归方式：递归边界为树的终止节点；
* 非递归方式：分为 **DFS**（深度优先）和**BFS**（广度优先） 的遍历方式。 <a href="https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/algorithm/dfs-bfs.md">DFS与BFS介绍</a>

**DFS** 根据以结点（Node）的访问顺序，定义了三种不同的搜索策略：（**记忆点：**前、中、后 标达的时结点的访问顺序，其中左子树优先右子树遍历）

* 前序遍历：结点 -> 左子树 -> 右子树 
* 中序遍历：左子树-> 结点 -> 右子树
* 后续遍历：左子树-> 右子树 -> 结点

如图：

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/tree-search.png)

* 前序: F - B - A - D - C - E - G - I - H
* 中序: A - B - C - D - E - F - G - H - I
* 后序: A - C - E - D - B - H - I - G - F

## <span id="avg-tree">平衡二叉树</span>(AVL)

基于**二分法的策略调高查询速度的二叉树的数据结构**，

#### 主要特点：

* 非叶子节点最多有两个子节点；
* 非叶子节点值大于左边子节点、小于右边子节点；
* 树的左右两边的层级数相差不会大于1；（左树的高度减去右数的高度的差，即平衡因子）
* 没有值相等的重复节点；

AVL树的查询性能与树的层级（树高度 h) 成反比，**h值越小查询越快**。通过保证数据的左右边的节点高度相差不大于1，这样避免树形结构的由于**删除、增加导致树变成线性链表**的结构影响了查询效率，保证数据平衡查询速度近似于二分法查找。（为了保证左右端数据大致平衡，降低二叉树的查询难度，一般采用算法机制实现节点的数据结构平衡，如 <a href="">Treap</a>、<a href="">红黑树</a>）

#### 平衡的调整

分为四种情况：LL、LR、RR、RL

下面我们通过不断插入数据来说明几种不同的旋转方式:

<font color="red">注意：橘黄色的结点为旋转中心，黑色结点的为离插入结点最近的失衡结点。</font>

##### LR型

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/LR.png)

最开始插入数据16，3，7后的结构如上图所示，结点16失去了平衡，3为16的左孩子，7为失衡结点的左孩子的右孩子，所以为LR型，接下来通过两次旋转操作复衡，先通过以3为旋转中心，进行左旋转，结果如图所示，然后再以7为旋转中心进行右旋转，旋转后恢复平衡了。

##### LL型

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/LL.png)

在上面恢复平衡后我们再次插入数据11和9,发现又失去平衡了，这次失衡结点是16，11是其左孩子，9为其失衡结点的左孩子的左孩子，所以是LL型，以失衡结点的左孩子为旋转中心进行一次右旋转即可。

##### RR型

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/RR.png)

进一步插入数据26后又再次失衡了，失衡结点为7,很明显这是RR型，以失衡结点的右孩子为旋转中心左旋转一次即可。

##### RL型

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/RL.png)

再插入18后又再次失衡了，失衡结点为16，26为其右孩子，18为其右孩子的左孩子，为RL型，以失衡结点的右孩子为旋转中心，进行一次右旋转，然后再次已失衡结点的右孩子为旋转中心进行一次左旋转变恢复了平衡。

这就是4中旋转方式，其实只有两种，RR和LL，RL和LR本质上是一样的。下面我们再次插入数据14，15，完成我们最后数据的插入操作：

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/LLRR.png)

又是一次LR型，按前面操作就可以了。

## <span id="b-tree">B tree</span>

注意：B树、B-tree、B-树是同一种数据结构。

#### 概念： 

B树与平衡二叉树稍有不同，B树属于**多叉树**又名**平衡多路查找树**（查找路径不只两个），数据库中索引技术大量使用B树和B+树的数据结构。

#### 特点：

B树与平衡二叉树不同是，每个节点包含的关键字增多，特别是在B树应用到数库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来。参考：<a href="">磁盘读取数据介绍</a>）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;

#### 规则:

1. 排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
2. 子节点数：非叶节点的子节点数>1，且<=M ，且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；
3. 关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如**ceil(1.1)结果为2**);
4. 所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;

最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C>B>A）

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/btree.jpg)

* **B树的查询流程：**

如上图我要从上图中找到E字母，查找流程如下

1. 获取根节点的关键字进行比较，当前根节点关键字为M，E<M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；

2. 拿到关键字D和G，D<E<G 所以直接找到D和G中间的节点；

3. 拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；

* **B树的插入节点流程**:

  定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来;

  遵循规则：

  1. 节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须<=5-1（这里关键字数>4就要进行节点拆分）；
  2. 排序规则：满足节点本身比左边节点大，比右边节点小的排序规则;

  **先插入 3、8、31、11**

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/btree1.jpg)
**再插入23、29**

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/btree2.png)
**再插入50、28**

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/btree3.png)

* **B树节点的删除**

  **规则：**

1. 节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数<2就要进行节点合并）；

2. 满足节点本身比左边节点大，比右边节点小的排序规则;

3. 关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/btree4.png)

## <span id="b+-tree">B+ tree</span>

#### 概念

B+树是B树的升级版，相对于B树，B+更充分的利用了节点空间，让查询速度更稳定。

#### 规则

1. B+树与B树不同，B+树的非叶子节点不保存关键记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；
2. B+树叶子节点保存了父节点的所有关键字记录的指针，所有**数据地址必须要到叶子节点才能获取到**。所以每次数据查询的次数都一样；
3. B+树叶子节点的关键字从小到大有序排列，**左边结尾数据都会保存右边节点开始数据的指针**；
4. 非叶子节点与关键字数量关系：（两种实现方式）
   * Mysql的B+树： 非叶子节点的子节点数=关键字数
   * 非叶节点的关键字数=子节点数-1

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/B+tree.jpg)

**(MySQL B+树示意图)**

#### 特点

1. B+**树的层级更少**：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；

2. B+**树查询速度更稳定**：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

3. B+**树天然具备排序功能：**B+树所有的叶子节点数据构成了一个有序链表，在**查询大小区间的数据时候更方便**，数据紧密性很高，缓存的命中率也会比B树高。

4. B+**树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于**数据库做全表扫描**。

**B树**相对于**B+树**的优点是，如果经常访问的数据离根节点很近，而**B树**的**非叶子**节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比**B+树**快。

## <span id="bb-tree">B* tree</span>

#### 规则

B*树是B+树的变种，相对于B+树他们的不同之处如下：

1. 首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b\*树的初始化个数为（cei(2/3*m)）
2. B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；

#### 特点

在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/B++tree.jpg)

##  <span id="summary">总结</span>

**相同思想和策略**

从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；

**不同的方式的磁盘空间利用**

不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；



## 补充

附：[B树和B+树的插入、删除图文详解 - nullzx - 博客园](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/nullzx/p/8729425.html)

附：[数据库磁盘]()
