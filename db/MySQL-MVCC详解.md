# MySQL-MVCC 详解

## MVCC介绍

全称 Multi-Version Concurrency Control  多版本控制，主要目的为提高数据库的并发性能(InnoDB引擎下)。对同一行的数据发生并发读写时，为了避免数据冲突，可以通过上锁阻塞实现。MVCC则不用增加锁，用更好的方式处理了读-写请求的并发问题。（此处的读是快照读，读分为快照读、当前读）

## 快照读与当前读

### 当前读

读的数据库中的记录都是当前最新的版本，会对当前读取记录进行加锁，防止其他事务修改数据。(悲观锁)

如下操作都是当前读：

* select ... lock in shard mode（共享锁）
* select ... for update（排他锁）
* update（排他锁）
* insert（排他锁）
* delete（排他锁）
* serializable 串行化事务隔离级别

### 快照读

读的实现基于MVCC，快照读读取的数据不一定是当前最新的版本，有可能是历史版本

如下操作都是快照读

* 不加锁的select （隔离级别不是serializable）

**快照读与MVCC的关系：** MVCC是维持一个数据多个版本，使读写操作没有冲突的一个概念，具体实现是快照读。

## MVCC解决并发

### 数据库并发场景

* 读 - 读：不存在问题，不需要并发控制
* 读 - 写：线程安全问题，造成事务隔离性问题，如：脏读、幻读、不可重复读
* 写 - 写：线程安全问题，存在更新丢失问题，如：第一类更新丢失、第二类更新丢失 [详情](#F-S-INFO)

### 解决哪些问题

MVCC用来解决**读 - 写**冲突的无锁的并发控制，为事务分配递增的时间戳（事务id）。为每个数据修改保存一个版本，版本与事务时间戳相关联。读操作只读取该**事务开始前**对应的**数据库快照**。可以做到读操作不用阻塞写操作，同时写操作不会阻塞读操作。解决了**脏读**、**幻读**、**不可重复读**等事务隔离性的问题，但是未解决 **写 - 写 更新丢失问题** 。（[如何解决写 - 写更新丢失](#F-S-SOLVE)）

## MVCC实现原理

MVCC实现通过**版本链**、**undo日志**、**ReadView**来实现的

### 版本链

数据库隐藏字段：**事务ID**、**回滚指针**、**自增ID**、**删除标示**

* db_trx_id：6 byte，最近更新（修改、插入）事务ID，记录最后一次修改、插入数据行的事务ID；
* db_roll_pointer: 7 byte, 回滚指针指向该记录的上一个版本（存储在rollback segment里）；
* dd_row_id: 6 byte，隐藏自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以db_row_id生产一个聚簇索引；
* 删除flag：隐藏字段, 记录被更新或删除并不代表真的删除，而是**删除flag**变了。

数据行（示例）：

| name | age  | db_row_id(隐式主键) | db_trx_id(事务ID) | db_roll_pointer(回滚指针) |
| ---- | ---- | ------------------- | ----------------- | ------------------------- |
| will | 32   | 1                   | 1                 | 0x12445444                |

如上表，db_row_id是数据库默认为该记录生成的唯一隐式索引，db_trx_id记录了当前操作的事务ID，而 db_roll_pointer回滚指针，通过undo日志，指向上一个旧版本。

每次对数据库记录进行改动，都会记录undo日志，每个undo日志都有一个db_roll_pointer属性（insert操作对应的undo日志中没有该属性，因为该记录没有更早的版本）。可以通过undo日志中的db_roll_pointer串联日志，形成一个链表。如图：

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/db_roll_pointer%E6%97%A5%E5%BF%97%E9%93%BE.png)

对记录进行每次更新后，都会将旧值放入到undo日志中，随着多次更新，所有的版本都通会被db_roll_pointer属性连接形成一条链表，称之为<font color="red">**版本链**</font>，版本链的头部是该记录的最新值。每个版本中都包含该版本对应的事务ID，在根据ReadView判断版本时会用到。

### undo日志（[MySQL事务日志简介](#mysql-log)）

undo log主要用于记录被修改前的日志，在表信息修改前先会把数据拷贝到undo log里。当**数据回滚**时通过undo log中的数据进行数据还原。

#### 用途

* 保证事务进行回滚时的原子性和一致性，当事务进行回滚的时候通过undo log 事务对应的数据进行恢复；
* 用于MVCC的快照读数据，在多版本控制时，通过undo log 的历史数据可以实现**不同事务版本号**都拥有自己的**独立快照数据版本**。

#### 种类

* insert undo log : 代表事务在insert时产生的undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃；
* update undo log：事务在update或delete时产生的undo log，不仅事务回滚需要，快照读时也需要。不可随便删除，只有在快照读或者事务回滚不涉及该日志时，对应的日志才可以被purge线程统一清除。

### Read View(读视图)

事务进行快照读操作时产生**读视图**(read view)，在该事务执行的快照读时，会生成数据库系统当前的一个快照。

记录并维护系统当前**活跃的事务ID**（没有提交，当每个事务开启时，都会分配一个事务ID，这个ID是递增的），即系统不该被当前读事务看到的其他事务ID列表。

Read View主要用来做**可见性**的判断，即当某个事务执行快照读的时候，对该记录创建一个Read View视图，把它作为条件用来判断**当前事务可以看到哪个版本的数据**，可以是最新数据也可以是undo log中的版本数据。

#### 属性

* trx_ids: 当前系统活跃（未提交）版本号集合；
* low_limit_id: 创建当前 Read View时，最大事务版本号+1；
* up_limit_id: 创建当前Read View时，系统活页事务最小版本号；
* creator_trx_id: 创建当前Read View的事务版本号。

#### 可见性判断（源码）

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/read-view-code.png)

* `db_trx_id` < `up_limit_id` || `db_trx_id` == `creator_trx_id`（显示）
  * 如果数据事务ID小于read view中的**最小活跃事务ID**，则可以肯定该数据是在当前事务启之前就已经存在了的,所以可以显示。
  * 或者数据的`事务ID`等于`creator_trx_id` ，那么说明这个数据就是当前事务`自己生成的`，自己生成的数据自己当然能看见，所以这种情况下此数据也是可以`显示`的。

* `db_trx_id` >= `low_limit_id`（不显示）
  * 如果数据事务ID大于read view 中的当前系统的`最大事务ID`，则说明该数据是在当前read view 创建`之后才产生`的，所以数据`不显示`。如果小于则进入下一个判断
* `db_trx_id`是否在`活跃事务`（trx_ids）中
  * `不存在`：则说明read view产生的时候事务`已经commit`了，这种情况数据则可以`显示`。
  * `已存在`：则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的。











## 补充内容

### <span id="F-S-INFO">第一类更新与第二类更新丢失 </span>

### 第一类

| 时间 | 事务A                                 | 事务B                |
| ---- | ------------------------------------- | -------------------- |
| t1   | **开始事务**                          |                      |
| t2   |                                       | **开始事务**         |
| t3   | 查询账户余额为1000元                  |                      |
| t4   |                                       | 查询账户余额为1000元 |
| t5   |                                       | 把余额改为1100元     |
| t6   |                                       | **提交事务**         |
| t7   | 把余额改为900元                       |                      |
| t8   | **回滚事务**                          |                      |
| t9   | **余额恢复为1000** **元（丢失更新）** |                      |

### 第二类

| 时间 | 事务A                | 事务B                               |
| ---- | -------------------- | ----------------------------------- |
| t1   | **开始事务**         |                                     |
| t2   |                      | **开始事务**                        |
| t3   | 查询账户余额为1000元 |                                     |
| t4   |                      | 查询账户余额为1000元                |
| t5   | 把余额改为900元      |                                     |
| t6   | ** 提交事务**        |                                     |
| t7   |                      | 把余额改为1100元                    |
| t8   |                      | **提交事务**                        |
| t9   |                      | **余额改为1000** **元（丢失更新）** |

### <span id="F-S-SOLVE">第一类更新与第二类更新丢失如何解决 </span>





### <span id="mysql-log">MySQL 事务日志</span>

事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。
 如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。

MySQL Innodb中跟数据持久性、一致性有关的日志，有以下几种：

- Bin Log:是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的
- Redo Log:记录了数据操作在物理层面的修改，mysql中使用了大量缓存，修改操作时会直接修改内存，而不是立刻修改磁盘，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。
- Undo Log: 除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC
