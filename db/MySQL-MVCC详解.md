# MySQL-MVCC 详解

## MVCC介绍

全称 Multi-Version Concurrency Control  多版本控制，主要目的为提高数据库的并发性能(InnoDB引擎下)。对同一行的数据发生并发读写时，为了避免数据冲突，可以通过上锁阻塞实现。MVCC则不用增加锁，用更好的方式处理了读-写请求的并发问题。（此处的读是快照读，读分为快照读、当前读）

## 快照读与当前读

### 当前读

读的数据库中的记录都是当前最新的版本，会对当前读取记录进行加锁，防止其他事务修改数据。(悲观锁)

如下操作都是当前读：

* select ... lock in shard mode（共享锁）
* select ... for update（排他锁）
* update（排他锁）
* insert（排他锁）
* delete（排他锁）
* serializable 串行化事务隔离级别

### 快照读

读的实现基于MVCC，快照读读取的数据不一定是当前最新的版本，有可能是历史版本

如下操作都是快照读

* 不加锁的select （隔离级别不是serializable）

**快照读与MVCC的关系：** MVCC是维持一个数据多个版本，使读写操作没有冲突的一个概念，具体实现是快照读。

## MVCC解决并发

### 数据库并发场景

* 读 - 读：不存在问题，不需要并发控制
* 读 - 写：线程安全问题，造成事务隔离性问题，如：脏读、幻读、不可重复读
* 写 - 写：线程安全问题，存在更新丢失问题，如：第一类更新丢失、第二类更新丢失 [详情](#F-S-INFO)

### 解决哪些问题

MVCC用来解决**读 - 写**冲突的无锁的并发控制，为事务分配递增的时间戳（事务id）。为每个数据修改保存一个版本，版本与事务时间戳相关联。读操作只读取该**事务开始前**对应的**数据库快照**。可以做到读操作不用阻塞写操作，同时写操作不会阻塞读操作。解决了**脏读**、**幻读**、**不可重复读**等事务隔离性的问题，但是未解决 **写 - 写 更新丢失问题** 。（[如何解决写 - 写更新丢失](#F-S-SOLVE)）

## MVCC实现原理

MVCC实现通过**版本链**、**undo日志**、**ReadView**来实现的

### 版本链

数据库隐藏字段：**事务ID**、**回滚指针**、**自增ID**、**删除标示**

* db_trx_id：6 byte，最近更新（修改、插入）事务ID，记录最后一次修改、插入数据行的事务ID；
* db_roll_pointer: 7 byte, 回滚指针指向该记录的上一个版本（存储在rollback segment里）；
* dd_row_id: 6 byte，隐藏自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以db_row_id生产一个聚簇索引；
* 删除flag：隐藏字段, 记录被更新或删除并不代表真的删除，而是**删除flag**变了。

数据行（示例）：

| name | age  | db_row_id(隐式主键) | db_trx_id(事务ID) | db_roll_pointer(回滚指针) |
| ---- | ---- | ------------------- | ----------------- | ------------------------- |
| will | 32   | 1                   | 1                 | 0x12445444                |

如上表，db_row_id是数据库默认为该记录生成的唯一隐式索引，db_trx_id记录了当前操作的事务ID，而 db_roll_pointer回滚指针，通过undo日志，指向上一个旧版本。

每次对数据库记录进行改动，都会记录undo日志，每个undo日志都有一个db_roll_pointer属性（insert操作对应的undo日志中没有该属性，因为该记录没有更早的版本）。可以通过undo日志中的db_roll_pointer串联日志，形成一个链表。如图：

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/db_roll_pointer%E6%97%A5%E5%BF%97%E9%93%BE.png)





















## 补充内容

### <span id="F-S-INFO">第一类更新与第二类更新丢失 </span>

### 第一类

| 时间 | 事务A                                 | 事务B                |
| ---- | ------------------------------------- | -------------------- |
| t1   | **开始事务**                          |                      |
| t2   |                                       | **开始事务**         |
| t3   | 查询账户余额为1000元                  |                      |
| t4   |                                       | 查询账户余额为1000元 |
| t5   |                                       | 把余额改为1100元     |
| t6   |                                       | **提交事务**         |
| t7   | 把余额改为900元                       |                      |
| t8   | **回滚事务**                          |                      |
| t9   | **余额恢复为1000** **元（丢失更新）** |                      |

### 第二类

| 时间 | 事务A                | 事务B                               |
| ---- | -------------------- | ----------------------------------- |
| t1   | **开始事务**         |                                     |
| t2   |                      | **开始事务**                        |
| t3   | 查询账户余额为1000元 |                                     |
| t4   |                      | 查询账户余额为1000元                |
| t5   | 把余额改为900元      |                                     |
| t6   | ** 提交事务**        |                                     |
| t7   |                      | 把余额改为1100元                    |
| t8   |                      | **提交事务**                        |
| t9   |                      | **余额改为1000** **元（丢失更新）** |

### <span id="F-S-SOLVE">第一类更新与第二类更新丢失如何解决 </span>
