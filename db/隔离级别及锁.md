# MySQL 锁、隔离级别、死锁问题

### 1. 数据库的事务特性

| 特性                  | 内容                                                         |
| --------------------- | :----------------------------------------------------------- |
| 原子性（Atomic）      | 事务中的多个操作，不可分割。要么都成功、要么都失败           |
| 一致性（Consistency） | 事务操作后，数据库所处的状态与业务规则一致。eg：a账户100， b账户90 ，a向b转钱10。 a账户90，b账户100，总金额应保持不变 |
| 隔离性（Isolation）   | 多个事务执行，之间不互相影响                                 |
| 持久性（Durability）  | 事务提交后被持久化到永久存储                                 |

### 2.隔离级别

##### 在介绍隔离级别前首先，先讨论一下，多用户并发操作可能会发生的问题： 

1. **脏读**：可以读取未提交事务的数据；
2. **不可重复读**：同一个事务中多次执行同一个select，读取到的数据发生了改变；
3. **幻读**：同一个事务中多次执行同一个select，读取到的数据**行数**发生了改变。（行数减少或者增加，被其他事务 insert/delete并且提交）。

##### **不可重复读**和**幻读**的区分：

* **不可重复读**：同一个select语句，获得到的数据字段值发生变化；重点在<font color='red'>修改</font>
* **幻读**：同一个select语句，获取到的数据的数量不一样；重点在于<font color="red">新增或者删除</font>

从结果上看一个是数据值不一样、一个是数据记录数不一样。从避免问题发生的实现的角度看，区别较大：（已下内容先做了解，gap lock  MVCC后续会详细介绍）

* 对前者，[**RC**](#RC) 只需要锁定满足条件的记录，避免其他事务修改。eg：select ... for update,select ... in shard mode; [**RR**](#RR) 隔离下使用MVCC实现可重复读；
* 对后者，要锁定满足条件的记录及所有记录之间的间隙(gap)，需要使用到gap lock。


| 隔离级别                                                     | 内容                                                         | 幻读       | 不可重复读 | 脏读       |
| :----------------------------------------------------------- | ------------------------------------------------------------ | ---------- | ---------- | ---------- |
| 可串行化serializable(<span id="S">**S**</span>)             | 强制事务串行化执行                                           | **不允许** | **不允许** | **不允许** |
| 未提交读 <br> read uncommitted(<span id="RU">**RU**</span>) | 可以读取未提交的数据(未提交的数据称为**脏读**)               | **允许**   | **允许**   | **允许**   |
| 已提交读 <br>read committed(<span id="RC">**RC**</span>)    | 只能读取已提交的数据                                         | **允许**   | **允许**   | **不允许** |
| 可重复读 <br>repeatable read(<span id="RR">**RR**</span>)   | 一个事务中，多次执行同一个select，获取的数据不发生改变 （**使用MVCC实现，后文详细介绍**） | **允许**   | **不允许** | **不允许** |


[扩展：RC 与 RR 的区别](#RC_RR_DIFF)

### 3.MySQL锁（以下重点介绍InnoDB引擎）

MySQL的存储引擎分为MyISAM和InnoDB，其中MyISAM支持**表级锁**，InnoDB支持**表记锁**、**行级锁**（<font color='red'>默认</font>）

|名称|特点|
|----|-----|
|表级锁|开销小，加锁快，锁力度大。发生冲突的概率最高，并发度最低，不会出现死锁|
|行级锁|开销大，加锁慢，锁力度最小。发生冲突概率最低，并发度最高，会出现死锁|
|页面锁|开销和加锁时间介于表、行级锁之间。锁力度介于表、行之间，并发度一般，会出现死锁|
#### InnoDB的行锁模式
行锁的实现方式：InnoDB的行锁通过索引上的索引项来实现（Oracle通过对数据中相应数据行加锁来实现），即**只用通过索引条件检索数据，InnoDB才会使用行级锁，否则将使用表级锁**。实际应用中，需要注意行锁的特点，不然会导致大量的锁冲突，影响并发性能。


|名称|描述|加锁方式|
|-----|-----|------|
|共享锁(<span id="S">**S**</span>)|读锁，加了S锁的记录，允许其他事物再加S锁，不允许再加X锁|普通查询(select)InnoDB自动增加S锁，查询显式加锁：select ... lock in share mode|
|排他锁(<span id="X">**X**</span>)|写锁，加了X锁的记录，不允许其他事物再加S锁或者X锁|执行写操作(update,delete,insert)InnoDB自动增加X锁，查询显示加锁：select ... for update|
|意向共享锁(<span id="IS">**IS**</span>)|事物在打算给数据行增加**S**锁时，事物会在加锁之前增加一个**IS**锁(**表级**)|由InnoDB自动加，无须用户干预|
|意向排他锁(<span id="IX">**IX**</span>)|事物在打算给数据行增加**X**锁时，事物会在加锁之前增加一个**IX**锁(**表级**)|同上|

##### Q：意向锁是表级锁？
当我们增加一个排他锁时，需要根据意向锁去判断是否有没有数据行被锁定（行锁）：

* 如果意向锁是行锁，需要遍历每一行数据去确认；
* 如果意向锁是表锁，只需要判断一次可知道有没有数据行被锁定，性能好；

#### 兼容性对比
**注意：上了行级X锁后，行级X锁不会因为有别的事物上IX而堵塞，一个mysql是允许多个行级X锁同时存在，只要他们不是针对<font color='red'>相同的数据行</font>**


|当前锁模式与请求模式是否兼容|X|IX|S|IS|
|----|-----|----|----|----|
|X|冲突|冲突|冲突|冲突|
|IX|冲突|兼容|冲突|兼容|
|S|冲突|冲突|兼容|兼容|
|IS|冲突|兼容|兼容|兼容|


