# 聚簇索引与非聚簇索引

## 区别

聚簇索引&非聚簇索引的主要区别：叶节点是否存放一整行的记录。

InnoDB主键索引使用的是聚簇索引，MyISAM 主键索引、二级索引都是用的是非聚簇索引

如下图展示区别：
![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/%E8%81%9A%E7%B0%87%26%E9%9D%9E%E8%81%9A%E7%B0%87%E5%8C%BA%E5%88%AB%E7%AE%80%E5%9B%BE.jpg)

* MyISAM（右边），表数据和索引是分成两部分存储的，Primary Key（主键索引简称PK）与 Secondary Key（二级索引）存储上没有本质的区别。都是用B+树作为索引的存储结构（<a href="">算法详情</a>），所有的节点存储的都是索引，叶子节点存储的是索引+索引对应的记录的数据。
* InnoDB（左边），表数据与主键一起存储，主键索引的叶节点存储行数据（包含主键值），二级索引的叶节点存储行的主键值。使用B+树作为存储结构，非叶子节点都是索引的关键字（关键字中不存储对应记录的具体内容或内容地址）。叶子节点上的数据是主键与数据内容。

### MyISAM中的B+树 

**MYISAM中叶子节点的数据区域存储的是数据记录的地址**

**主键索引**

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/myisam-B%2B.jpg)

**二级索引（辅助索引）**

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/myisam-B%2B1.jpg)

MyISAM存储引擎在使用索引查询数据时，会先根据索引查找到数据地址，再根据地址查询到具体的数据。并且主键索引和辅助索引没有太多区别。

### InnoDB中的B+树

**InnoDB中主键索引的叶子节点的数据区域存储的是数据记录，辅助索引存储的是主键值**

**主键索引**

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/innodb-B%2B.jpg)

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/innodb-b%2B1.jpg)

**二级索引**

![avatar](https://github.com/craftlook/Hello-World/blob/craftlook-Hello-World/image/innodb-B%2B2.jpg)

Innodb中的主键索引和实际数据时绑定在一起的，也就是说Innodb的一个表一定要有主键索引，如果一个表没有手动建立主键索引，Innodb会查看有没有唯一索引，如果有则选用唯一索引作为主键索引，如果连唯一索引也没有，则会默认建立一个隐藏的主键索引（用户不可见）。另外，Innodb的主键索引要比MyISAM的主键索引查询效率要高（少一次磁盘IO），并且比辅助索引也要高很多。所以，我们在使用Innodb作为存储引擎时，我们最好：

* 手动建立主键索引
* 尽量利用主键索引查询

**总结**：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值

## 聚簇索引的优点&缺点

### 优点

1. 由于行数据与叶子节点存储再一起，同一页中会有多条行数据，访问同一**数据页**不同的数据时，已经把页中的内容加载到缓存中，再次访问的时候，会从**内存中完成访问，不必访问磁盘**。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快；
2. 当获取一定范围的数据时，用聚簇索引比非聚簇好；
3. 聚簇索引一次定位寻找，非聚簇索引需要进行二次定位。第一次定位到聚簇索引的索引值，再通过非聚簇索引查找对应的数据；

**补充**：辅助索引使用主键作为"指针"而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"。也就是说行的位置（实现中通过16K的Page来定位）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。（**空间换时间：地址指针比索引值空间上要小，用地址指针数据移动时需要进行索引维护，地址指针比索引值时间上理论上要长**）

### 缺点

1. 维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。
2. 表如果使用随机ID作为主键，使数据存储稀疏，这就会出现聚簇索引比扫全表慢的情况。所以建议主键的值是顺序的。

**补充**：

**为什么主键通常建议使用自增id**

**聚簇索引的数据的物理存放顺序与索引顺序是一致的**，即：**只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的**。如果主键不是自增id，那么可以想 象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。

因为**MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转**。**聚簇索引则只需一次I/O**。（强烈的对比）

不过，如果**涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的**。
